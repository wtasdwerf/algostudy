<br/><Br>

<span style = "color:orange">

# 문제 제목
</span>
<br>

> https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AYmbBU3a7cwDFAUe&contestProbId=AV14ABYKADACFAYh&probBoxId=AYmbBnEa7eIDFAUe&type=PROBLEM&problemBoxTitle=HOMEWORKS&problemBoxCnt=4


<br/><br>

## 문제

> ※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.
>
> 점심 시간에 산책을 다니는 사원들은 최근 날씨가 더워져, 사다리 게임을 통하여 누가 아이스크림을 구입할지 결정하기로 한다.
>
> 김 대리는 사다리타기에 참여하지 않는 대신 사다리를 그리기로 하였다.
>
> 사다리를 다 그리고 보니 김 대리는 어느 사다리를 고르면 X표시에 도착하게 되는지 궁금해졌다. 이를 구해보자.
>
> 아래 <그림 1>의 예를 살펴보면, 출발점 x=0 및 x=9인 세로 방향의 두 막대 사이에 임의의 개수의 막대들이 랜덤 간격으로 추가되고(이 예에서는 2개가 추가됨) 이 막대들 사이에 가로 방향의 선들이 또한 랜덤하게 연결된다.
>
> X=0인 출발점에서 출발하는 사례에 대해서 화살표로 표시한 바와 같이, 아래 방향으로 진행하면서 좌우 방향으로 이동 가능한 통로가 나타나면 방향 전환을 하게 된다.
>
> 방향 전환 이후엔 다시 아래 방향으로만 이동하게 되며, 바닥에 도착하면 멈추게 된다.
>
> 문제의 X표시에 도착하려면 X=4인 출발점에서 출발해야 하므로 답은 4가 된다. 해당 경로는 별도로 표시하였다.

**100 x 100 크기의 2차원 배열로 주어진 사다리에 대해서, 지정된 도착점에 대응되는 출발점 X를 반환하는 코드를 작성하라** (‘0’으로 채워진 평면상에 사다리는 연속된 ‘1’로 표현된다. 도착 지점은 '2'로 표현된다).

**[제약 사항]**

한 막대에서 출발한 가로선이 다른 막대를 가로질러서 연속하여 이어지는 경우는 없다.

**[입력]**

입력 파일의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며, 바로 다음 줄에 테스트 케이스가 주어진다.

총 10개의 테스트 케이스가 주어진다.

**[출력]**

\#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 도착하게 되는 출발점의 x좌표를 출력한다.



<br/><br>

## 풀이

```python
import sys
sys.stdin = open('input.txt')

for tc in range(1, 11):
    N = int(input())
    arr = [list(map(int, input().split()))for _ in range(100)]

    # 출구의 행 인덱스[j]를 찾고 x로 정의해주기
    x = 0
    for j in range(100):
        if arr[99][j] == 2:
            x = j

    y = 99
    # y가 0이 되서 while 문 빠져나오는 순간 x값이 출발점
    while y > 0:

        #18번줄 # 만약 같은행 오른쪽 열의 값이 1이라면, 또 열이 99를 넘지 않았다면
        if (arr[y][x+1] == 1) and (x < 99) : # a = [1, 2, 3]일때 a[3]을 찾는건 오류다!
            # 그 조건이 계속 유지되는 한
            while (arr[y][x+1] == 1) and(x < 99):
                # 열의 값을 계속 1씩 계속 증가시킨다
                x += 1
                # print(x , end = ',')
            # 근데 오른쪽에 1이 없다면??? 위로 올라가야지 (왼쪽으로 다시 돌아가면 안되니깐)
            else:
                y -= 1 
        # 28번줄

        # 만약 같은행 왼쪽 열의 값이 1이라면, 또 열이 99를 넘지 않았다면
        elif (arr[y][x-1] == 1) and (x > 1):
            # 그 조건이 계속 유지되는 한
            while (arr[y][x - 1] == 1) and (x > 1):
                # 열의 값을 계속 1씩 계속 감소시킨다
                x -= 1
            # 근데 왼쪽에 1이 없다면? 위로 올라가야지 (오른쪽으로 다시 돌아가면 안되니깐)
            else:
                y -= 1

        # 이 모든게 아니라면 당연히 위에 1이 있을수밖에 없으니깐
        else:
            # 위로 올라간다
            y -= 1
    # print()
    print(f'#{tc} {x}')

```
<br>

> 풀이설명

<br/><br>


## 의문점
> 문제
> 
> - 코드를 돌려보면 알겠지만 어느 테스트케이스에서는 되다가 21번 줄에서 오류가 뜹니다
>   
>- **<u>어느 조건에서 왜 안되는지 이유를 파악</u>**해보세요~
>   
>- 코드를 다 해석하지 않고 (vscode기준) 18번부터 27번줄까지 논리구조만 보고 문제를 알아차릴 수 있습니다~!!
>   
>- (제가 한시간 반동안 이거때메 못풀고 헤매고 있다가 풀고 깜짝 놀랬습니다 하하)
>   
>
> 

<br/><br>


## 배운점
> 
>
> 

