<br/><Br>

<span style = "color:orange">

# 문제 제목
</span> 감시 피하기
<br>

> 출처 : [백준 18428 : 감시 피하기](https://www.acmicpc.net/problem/18428)


<br/><br>

## 문제

> NxN 크기의 복도가 있다. 복도는 1x1 크기의 칸으로 나누어지며, 특정한 위치에는 선생님, 학생, 혹은 장애물이 위치할 수 있다. 현재 몇 명의 학생들은 수업시간에 몰래 복도로 빠져나왔는데, 복도로 빠져나온 학생들은 선생님의 감시에 들키지 않는 것이 목표이다.

각 선생님들은 자신의 위치에서 상, 하, 좌, 우 4가지 방향으로 감시를 진행한다. 단, 복도에 장애물이 위치한 경우, 선생님은 장애물 뒤편에 숨어 있는 학생들은 볼 수 없다. 또한 선생님은 상, 하, 좌, 우 4가지 방향에 대하여, 아무리 멀리 있더라도 장애물로 막히기 전까지의 학생들은 모두 볼 수 있다고 가정하자.

입력

첫째 줄에 자연수 N이 주어진다. (3 ≤ N ≤ 6) 둘째 줄에 N개의 줄에 걸쳐서 복도의 정보가 주어진다. 각 행에서는 N개의 원소가 공백을 기준으로 구분되어 주어진다. 해당 위치에 학생이 있다면 S, 선생님이 있다면 T, 아무것도 존재하지 않는다면 X가 주어진다.

단, 전체 선생님의 수는 5이하의 자연수, 전체 학생의 수는 30이하의 자연수이며 항상 빈 칸의 개수는 3개 이상으로 주어진다.

출력 

첫째 줄에 정확히 3개의 장애물을 설치하여 모든 학생들을 감시로부터 피하도록 할 수 있는지의 여부를 출력한다. 모든 학생들을 감시로부터 피하도록 할 수 있다면 "YES", 그렇지 않다면 "NO"를 출력한다.


<br/><br>

## 풀이

```python
# 감시 피하기
import sys
input = sys.stdin.readline

# 설치한 장애물 개수가 3개일 때 적절히 설치했는지 확인해주는 함수
# 백트래킹 사용
def obstacle(c): # c : 설치한 장애물 개수
    global result

    # 장애물 세 개 설치 완료
    if c == 3:
        # 설치 완료된 상황에서 bfs 실행 결과, 감시 실패(목표 달성)의 경우 -> 케이스를 찾음
        if bfs():
            result = True # 성공했다면 result를 true로 초기화
            return
    # 아직 세 개 설치 미완
    else:
        # 빈 공간 중 세 곳에 장애물 설치 진행
        for x in range(N):
            for y in range(N):
                if arr[x][y] == "X":
                    arr[x][y] = "O"
                    obstacle(c + 1) # backTracking
                    arr[x][y] = "X" # 백트래킹 후 복원

# 세 개의 장애물 설치 완료 후 감시여부 확인
def bfs():
    dir = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    for i, j in t_position:# 선생님의 위치에서
        for di, dj in dir: # 상/하/좌/우 탐색
            ni = i + di
            nj = j + dj
            while 0 <= ni < N and 0 <= nj < N:
                if arr[ni][nj] == "O": # 선생님 기준 학생보다 먼저 장애물 만남 -> 방향전환
                    break

                elif arr[ni][nj] == "S": # 선생님 기준 장애물보다 먼저 학생 만남 -> 해당 장애물 좌표에 대해 목표달성 실패
                    return False
                # X를 만난 경우 -> 같은 방향에 대해 탐색 진행
                ni += di
                nj += dj

    # no return -> 목표 달성 성공(해당 좌표에 장애물 설치시 감시 실패)
    return True


N = int(input())
result = False
arr = [list(input().split()) for _ in range(N)]
t_position = []

# 반복문을 통해 복도 정보를 입력 받는다.
for i in range(N):
    for j in range(N):
        if arr[i][j] == "T": # 선생님이 있는 좌표를 저장
            t_position.append([i, j])


# 설치한 장애물 개수 0으로 백트래킹 시작
obstacle(0)

# result == True 즉, 감시 실패 상황 있음
if result:
    print('YES')
# result == False 즉, 감시 실패 상황 없음(항상 감시)
else:
    print('NO')
```
<br>

> 몇 가지 정보가 필요한 문제이다.
> 1. 선생님의 위치 정보
> 2. 어떤 식으로 3개의 장애물을 설치할 것인가?
> 3. 3개의 장애물을 설치했다면, 그 상태에서 선생님들의 감시를 피할 수 있는가?
> -> 피할 수 있는 장애물 설치 방법이 있을 시, 목표 달성 / 어떠한 장애물 설치에 대해서도 감시를 피할 수 없다면, 목표 달성 실패
>
> - 3개의 장애물을 설치하는 함수 / 3개의 장애물이 설치되었을 때, 그 상황에서 감시를 피할 수 있는지를 알아보는 함수 정의

<br/><br>


## 의문점
> 아직 백트래킹을 다루는 방법이 좀 많이 부족하다고 느낀다. 또한, bfs와 dfs를 문제에서 활용하는 것에도 조금 어려움이 있어 익숙한 문제를 만나도 쉽게 손을 대지 못하는 경우가 많다.


<br/><br>


## 배운점
> TIL

