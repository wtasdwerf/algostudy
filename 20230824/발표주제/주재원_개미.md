<br/><Br>

<span style = "color:orange">

# 문제 제목
개미

> 출처 : 링크 입력


<br/><br>

## 문제

> 문제설명

<br/><br>

## 풀이 - 시간 초과

```python
   N = int(input())
room = [0]

for _ in range(N):
    room.append(int(input()))

adj = [[] for _ in range(N+1)]
for _ in range(N-1):
    a, b, c = map(int, input().split())
    # 연결된 방과 굴의 깊이에 대한 값을 인접시키기
    adj[a].append((b, c))
    adj[b].append((a, c))

def dfs(power, room_num, start):
    ans[start] = room_num

    for go, energy in adj[room_num]:
        # 현재 힘이 소모될 에너지보다 작으면 이동이 불가
        if power >= energy and room_val[go][1] < room_val[room_num][1]:

            dfs(power - energy, go, start)

def bfs():

    room_val = [(0, 0)] * (N+1)
    val = 1
    q = []
    visit = [0] * (N+1)
    visit[1] = 1
    q.append(1)

    while q:
        for _ in range(len(q)):
            cur = q.pop(0)
            room_val[cur] = (cur, val)

            for go, energy in adj[cur]:
                if visit[go] == 0:
                    visit[go] = 1
                    q.append(go)

        val += 1
    return room_val

room_val = bfs()

ans = [0] * (N+1)

for i in range(1, N+1):
    dfs(room[i], i, i)
    print(ans[i])
 
```
<br>

> 풀이설명

연결된 방과 굴의 깊이에 대한 값을 인접시키기 위해서 a에는 b,c b에는 a,c를 추가하였고 현재 힘이 소모될 에너지보다 작으면 이동이 불가한 조건을 만들기 위해서 dfs 함수 내에서 비교하여 이동이 가능할 때에만 이동시키도록 하였다.

bfs 과정에서 큐의 가장 앞 값을 방 번호랑 연결 시키는 과정을 이해하지 못하여서 블로그를 참고하였고, 출력이 제대로 되는 것을 확인하였지만 시간 초과로 실행에는 실패하였습니다.


```python
   import sys, heapq

# INF : 무한대값
INF = 10000000000000000000000

# 입력부
n = int(sys.stdin.readline())
ant = []
for i in range(n):
    temp = int(sys.stdin.readline())
    ant.append(temp)

# 인접 리스트 생성
adj = [[] for _ in range(n)]
for i in range(n - 1):
    a, b, c = map(int, sys.stdin.readline().split())
    adj[a - 1].append((b - 1, c))
    adj[b - 1].append((a - 1, c))

# ans : 정답배열, 1번 방에 사는 개미는 항상 1번이 제일 가까우므로 1을 넣고 시작
ans = [1]


# dijstra : 다익스트라 알고리즘 + path 갱신
def dijstra(v):
    d[v] = 0
    min_q = []
    min_q.append((d[v], v))
    while len(min_q) != 0:
        distance = min_q[0][0]
        current = min_q[0][1]
        heapq.heappop(min_q)
        if d[current] < distance:
            continue
        for i in range(len(adj[current])):
            next = adj[current][i][0]
            nextdistance = adj[current][i][1] + distance
            if nextdistance < d[next]:
                d[next] = nextdistance
                # next에서 인접한 방들 중 가장 짧은 거리는 current다
                path[next].append(current)
                heapq.heappush(min_q, (nextdistance, next))


d = [INF] * n
path = [[] for _ in range(n)]

# 1번방 기준 다익스트라
dijstra(0)
for i in range(1, n):
    for j in adj[i]:
        # 만일 최단 거리 방이 맞다면, 그때의 에너지 소모량도 같이 저장한다
        if j[0] == path[i][0]:
            path[i].append(j[1])

# 1번 방의 경우 예외처리
path[0] = [0, 0]

for i in range(1, n):
    energy = ant[i]
    route = i
    # 지속적으로 path 배열을 타고 올라가다가 에너지가 0이하가 되면 정답 리턴
    while True:
        energy -= path[route][1]
        if energy < 0:
            ans.append(route + 1)
            break
        elif route == 0:
            ans.append(route + 1)
            break
        route = path[route][0]

# 정답 출력
for i in ans:
    print(i) 
```


## 의문점
> 해결되지 않은 부분


<br/><br>


## 배운점
> TIL

