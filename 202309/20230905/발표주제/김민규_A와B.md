<br/><Br>

<span style = "color:orange">

# A와 B
</span>
<br>

> 출처 : https://www.acmicpc.net/problem/12904


<br/><br>

## 문제

> 수빈이는 A와 B로만 이루어진 영어 단어가 존재한다는 사실에 놀랐다. 대표적인 예로 AB (Abdominal의 약자), BAA (양의 울음 소리), AA (용암의 종류), ABBA (스웨덴 팝 그룹)이 있다.

이런 사실에 놀란 수빈이는 간단한 게임을 만들기로 했다. 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다.

문자열의 뒤에 A를 추가한다.
문자열을 뒤집고 뒤에 B를 추가한다.
주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오. 

### 입력
첫째 줄에 S가 둘째 줄에 T가 주어진다. (1 ≤ S의 길이 ≤ 999, 2 ≤ T의 길이 ≤ 1000, S의 길이 < T의 길이)

### 출력
S를 T로 바꿀 수 있으면 1을 없으면 0을 출력한다.

<br/><br>

## 풀이

```python
start = list(input())
end = list(input())
result = 0

while len(start) < len(end):
    if end[-1] == 'A':
        end.pop()
    elif end[-1] == 'B':
        end.pop()
        end.reverse()

if start == end:
    result = 1

print(result)
```
<br>

> S라는 문자열을 두가지 연산만을 이용해 T로 바꿀 수 있는지 확인하는 문제이다. 두 문자열의 길이는 고정이기 때문에, 결국 연산을 반복하여 두 문자열의 길이가 같아 질 때 두 문자열의 동일여부를 확인하는 문제이다.

역으로, T를 S로 만드는 연산을 진행했다. 확인해야 할 것은 T의 끝 문자가 'A'인지, 'B'인지 보는 것이다. 결과에 따라 맞는 연산을 진행해 나가며 T를 S의 문자열 길이로 만들면 된다.

<br/><br>


## 의문점
> 해결되지 않은 부분


<br/><br>


## 배운점
> TIL
처음에는 S로 T를 만들어가는 과정을 생각하며, 여러개의 과정을 가지처럼 나누어 재귀함수로 구현해 보았다.
```python
# 내가 구현한 코드
def bfs(S):
    global result
    if len(S) == len(end):
        if S == end:
            result = 1
            return
    else:
        new1 = S + 'A'
        new2 = S[::-1] + 'B'
        bfs(new1)
        bfs(new2)

```
이처럼 각 케이스에 대해 2가지 방법의 연산을 진행 한 후, 연산을 진행한 두 가지 문자열에 대해 재귀를 반복하는 방식을 택했는데, 이러면 시간초과가 난다(각 문자열 별로 2번의 재귀함수 실행 -> 최악의 경우, S의 길이가 1이고, T의 길이가 1000이면 약 2**999번의 연산 시행)
sys모듈의 setrecursionlimit()을 사용했는데, 그렇게 큰 숫자는 아무리 한도를 풀어도 받지 못하는 것 같다. 그러다 생각한 것이, S에서 T로 가는 많은 방법 중 하나를 찾느 것이 아니라, 결국 T로 만드는 과정에서 필요한 연산을 역으로 추적해 나가는 것이었다. 여러가지 방법 중 하나를 찾지 못하면 꽝이기에, 보다 확실하게 판별할 수 있었다.